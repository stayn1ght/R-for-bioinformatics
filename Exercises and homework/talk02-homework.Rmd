---
title: "talk02 练习与作业"
documentclass: ctexart
output:
  rticles::ctex:
    fig_caption: yes
    number_sections: yes
    toc: true
    toc_depth: 2
  word_document: default
  html_document:
    df_print: paged
knit: (
  function(inputFile, encoding) { 

    pSubTitle <- 'talk02-homework'

    rmarkdown::render( 
      input       = inputFile, 
      encoding    = encoding, 
      params      = list(sub_title = pSubTitle),      
      output_file = pSubTitle) })
---

## 练习和作业说明

将相关代码填写入以 \`\`\`{r} \`\`\` 标志的代码框中，运行并看到正确的结果；

完成后，用工具栏里的"Knit"按键生成PDF文档；

**将生成的PDF**改为：**`姓名-学号-talk02作业.pdf`**，并提交到老师指定的平台/钉群。

## talk02 内容回顾

-   R language basic

    -   基本数据类型
    -   简单算术
    -   特别值

## 练习与作业：用户验证

请运行以下命令，验证你的用户名。

**如你当前用户名不能体现你的真实姓名，请改为拼音后再运行本作业！**

```{r}
Sys.info()[["user"]]
Sys.getenv("HOME")
```


## 练习1：vector的基本类型与简单算术

-   **用`class`命令确定以下`vector`的类型；**

`c(100, 20, 30)`

`c(" 字符串", " 数组"," 是我")`

`c(TRUE, FALSE, TRUE, T, F)`

```{r}
## 将代码写在此处，并运行，比如：
class(c(100, 20, 30));
class(c(" 字符串", " 数组"," 是我"))
class(c(TRUE, FALSE, TRUE, T, F))
```

------------------------------------------------------------------------

-   **用`class`命令确定以下`vector`的类型；**

`c(45, TRUE, 20, FALSE, -100)`

`c("string a", FALSE, "string b", TRUE)`

`c("a string", 1.2, "another string", 1e-3)`

```{r}
## 将代码写在此处，并运行
class( c(45, TRUE, 20, FALSE, -100) )
class( c("string a", FALSE, "string b", TRUE) )
class( c("a string", 1.2, "another string", 1e-3) )
```


**请解释为什么整个vector 的结果与单个成员的类型并不完全一致？**

**答：因为vector中的元素必须是同一种数据类型。在赋值时不同数据类型
会自动转化成同一类型。转化的顺序 bool -> int -> double -> string。**

------------------------------------------------------------------------

-   **运行以下代码：**

`x <- c(10,100,1000, 10000);`

`( y <- sqrt( x ) * 4 + 10 );`

```{r}
## 代码写在此处并运行
x <- c(10,100,1000, 10000)
( y <- sqrt( x ) * 4 + 10 )
```

**问：第二行代码最外层的括号有什么作用？**

答：显示运算结果

------------------------------------------------------------------------

-   **以下两个`vector`，计算它们的乘积：**

`x <- c(4,6,5,7,10,9,4,15)`

`y <- c(0,10,1,8,2,3,4,1)`

```{r}
## 代码写在此处并运行
x <- c(4,6,5,7,10,9,4,15)
y <- c(0,10,1,8,2,3,4,1)

x * y

```

------------------------------------------------------------------------

-   **以下两个`vector` ，计算： `a <= b` :**

`a <- c(1,5,4,3,6)`

`b <- c(3,5,2,1,9)`

```{r}
## 代码写在此处并运行
a <- c(1,5,4,3,6)
b <- c(3,5,2,1,9)
a <= b
```

------------------------------------------------------------------------

-   **将函数`dim is.numeric is.character is.logical length`应用到下面的`vector`，并展示结果；**

`x <- 1:12`

`y <- LETTERS[1:12]`

`z <- c(F, T, FALSE);`

```{r}
## 代码写在此处并运行
x <- 1:12
y <- LETTERS[1:12]
z <- c(F, T, FALSE)
name_ls <- c("x", "y", "z")
da_ls <- list(x, y, z)
print(paste(name_ls, "dim:", sapply(da_ls, dim)), sep = " ")

print(paste(name_ls, "is.numeric:", sapply(da_ls, is.numeric), sep = " "))

print(paste(name_ls, "is.character:", sapply(da_ls, is.character), sep = " "))

print(paste(name_ls, "is.logical:", sapply(da_ls, is.logical), sep = " "))

print(paste(name_ls, "length:", sapply(da_ls, length), sep = " "))
```


```

------------------------------------------------------------------------

-   **以下两个`vector` ，计算： `which(!is.finite(x/y))` :**

`x <- c(12:4)`

`y <- c(0,1,2,0,1,2,0,1,2)`

```{r}
## 代码写在此处并运行
x <- c(12:4)
y <- c(0,1,2,0,1,2,0,1,2)
which(!is.finite(x/y))

```

**提问：请解释输出结果的含义？**

答：!is.finite(x/y)返回一个逻辑向量，其中非有限数为TRUE，有限数为FALSE。which函数返回TRUE的位置。

------------------------------------------------------------------------

-   **以下两个`vector` ，计算： `x > y` :**

`x <- letters[1:10]`

`y <- letters[15:24]`

```{r}
## 代码写在此处并运行
x <- letters[1:10]
y <- letters[15:24]
x > y

```

------------------------------------------------------------------------

-   **以下`vector`** ：

`x <- c(4,6,5,7,10,9,4,15)`

计算：

`x < 7`

`x < c( 8, 4 ); ## 与第二个vector进行`

```{r}
## 代码写在此处并运行
x <- c(4,6,5,7,10,9,4,15)
x < 7
x < c( 8, 4 )

```

**问：请问第二个`vector`成员的循环规则是什么？这种循环在R里被称为什么？**

**答：第二个vector成员的循环规则是循环使用第二个vector中的元素，直到比较长的第一个vector中的元素用完。
这种循环在R里被称为循环重复。**

------------------------------------------------------------------------

-   **练习阶乘和取余操作：**

`2 ^ 6`

`1:10 ^ 2`

`5 %% 2`

`100:110 %% 2`

```{r}
## 代码写在此处并运行
2 ^ 6
# 乘方运算的优先级高于冒号运算
1:10 ^ 2 
5 %% 2
100:110 %% 2

```

------------------------------------------------------------------------

-   **将函数 `is.vector` 应用到以下数据：**

`c( 8, 9, 10)`

`T`

`7`

```{r}
is.vector(c( 8, 9, 10))
is.vector(T)
is.vector(7)

```

**问：后两个的输出结果是什么？`TRUE` or `FALSE`？为什么？**

**答**：输出的结果都是true。R中没有标量类型，“最小的”数据类型是向量。

## 练习2：`vector`操作

-   **合并：**

`a <- 1:3;`

`b <- LETTERS[1:3];`

`( ab <- c(a,b) );`

```{r}
## 代码写在此处并运行
a <- 1:3
b <- LETTERS[1:3]
(ab <- c(a,b))

```

------------------------------------------------------------------------

-   **用至少两个函数检测上面生成的变量`ab`的数据类型；**

```{r}
## 代码写在此处并运行
class(ab) # ab的类
typeof(ab) # ab的内部存储类型
mode(ab) # ab的模式

```

------------------------------------------------------------------------

-   **取vector的一部分**

先生成一个vector，并对其每个成员进行命名:

`v <- 1:10;`

`names( v ) <- letters[1:10];`

`v; ## 显示 v 的内容`

```{r}
## 代码写在此处并运行
v <- 1:10
names( v ) <- letters[1:10]
v

```

取部分操作：

`v[1]; ## index based method`

`v[ 2:5 ];`

`v[ c(1,3,9,2,5];`

`v[ "a" ];`

`v[ c( "a", "c", "b") ];`

**注：运行上述代码，并于每次运行后，显示 v 的当前值；**

```{r}
## 代码写在此处并运行
v[1]
v
v[ 2:5 ]
v
v[ c(1,3,9,2,5) ]
v
v[ "a" ]
v
v[ c( "a", "c", "b") ]
v

```

------------------------------------------------------------------------

-   **替换**

`v[ 1 ] <- 100;`

`v[2:3] <- 100;`

`v[ 3:5 ] <- c( 100, 200 );`

`v[ c(1, 5, 3 ) ] <- c(100, 500, 300);`

**注：运行上述代码，并于每次运行后，显示 v 的当前值；**

```{r}
## 代码写在此处并运行
v[ 1 ] <- 100
v
v[2:3] <- 100
v
v[ 3:5 ] <- c( 100, 200 )
v
v[ c(1, 5, 3 ) ] <- c(100, 500, 300)
v

```

------------------------------------------------------------------------

-   **在vector的后面增加一个成员；此操作会改变vector的长度；**

`a <- sample(1:20, 10);`

`length(a);`

`a[ length(a) + 1] <- 666;`

`length(a);`

`a;`

```{r}
## 代码写在此处并运行
a <- sample(1:20, 10)
length(a)
a[ length(a) + 1] <- 666
length(a)
a
```

------------------------------------------------------------------------

-   **以下两个vector相加，并查看结果；**

`p <- c (3, 5, 6, 8)`

`q <- c (3, 3, 3)`

```{r}
## 代码写在此处并运行
p <- c (3, 5, 6, 8)
q <- c (3, 3, 3)
p + q
```

------------------------------------------------------------------------

-   **取出下面vector中数据大于20的成员，并显示：**

a \<- sample( 1:50, 20 );

```{r}
## 代码写在此处并运行
a <- sample( 1:50, 20 )
a[a > 20]

```

## 练习3：逻辑检验和运算

-   **用函数 `isTRUE` 计算以下数值或表达式，查看结果；**

`T | F`

`T & F`

`5 | 0`

`5 & 6`

```{r}
## 代码写在此处并运行
isTRUE(T | F)
isTRUE(T & F)
isTRUE(5 | 0)
isTRUE(5 & 6)
```

**问题：为什么 `isTRUE( 5 )` 为 `FALSE`，`isTRUE( 6 )` 也为 `FALSE`，但 `isTRUE( 5 & 6 )`是 `TRUE`？**

答：isTRUE()函数相当于 { is.logical(x) && length(x) == 1 && !is.na(x) && x }，
即x是逻辑值，且长度为1，且不是NA，且为TRUE。而5和6都是数值，不是逻辑值，所以isTRUE(5)和isTRUE(6)都为FALSE。而5 & 6是逻辑运算，返回TRUE，所以isTRUE(5 & 6)为TRUE。

------------------------------------------------------------------------

-   **将 isTRUE 应用于以下数值，并查看结果：**

`-1`

`-100`

`0`

`1`

`100`

```{r}
## 代码写在此处并运行
isTRUE(-1)
isTRUE(-100)
isTRUE(0)
isTRUE(1)
isTRUE(100)
```

## 

## 练习4：matrix、计算及相关函数

-   **生成一个matrix，并查看结果，注意 `dimnames` 的用法：**

`m <- matrix( c(20, 30.1, 2, 45.8, 23, 14), nrow = 2, dimnames = list( c("row_A", "row_B"), c("A", "B", "C")));`

```{r}
## 代码写在此处并运行
m <- matrix( c(20, 30.1, 2, 45.8, 23, 14), nrow = 2, dimnames = list( c("row_A", "row_B"), c("A", "B", "C")))
m

```

------------------------------------------------------------------------

-   **在上面生成的变量 `m` 上运行以下函数：**

`dim`

`nrow`

`ncol`

`range`

`summary`

`colnames`

`rownames`

`t`

```{r}
## 代码写在此处并运行
fun_ls <- list(dim, nrow, ncol, range, summary, colnames, rownames, t)
for (fun in fun_ls) {
    print(fun(m))
}

```

------------------------------------------------------------------------

-   **用代码实现以下操作：**

a\. 取第一行

b\. 取第二列

c\. 同时取第三、二列，注意取的顺序；

**并且，用`class`函数检验得到结果的数据类型；**

```{r}
## 代码写在此处并运行
m[1, ]
m[, 2]
m[, c(3, 2)]
class(m[1, ])
class(m[, 2])
class(m[, c(3, 2)])
```

------------------------------------------------------------------------

-   **用代码实现以下操作：**

a\. 用 1-1000 之间随机数值（用`sample`函数取值）替换第一行；

b\. 用 1-1000 之间随机数值（用`sample`函数取值）替换第二列；


```{r}
## 代码写在此处并运行
m[1, ] <- sample(1:1000, length(m[1, ]))
m[, 2] <- sample(1:1000, length(m[, 2]))
m

```

## 练习5：特别值

-   **用以下函数或命令式检测特别值构成的`vector sp` ，报告输出结果**

`sp <- (NA, NaN, Inf, -Inf)`

`is.finite`

`! is.infinite`

`is.na`

`is.nan`

```{r}
## 代码写在此处并运行
sp <- c(NA, NaN, Inf, -Inf)
is.finite(sp)
!is.infinite(sp)
is.na(sp)
is.nan(sp)
```
